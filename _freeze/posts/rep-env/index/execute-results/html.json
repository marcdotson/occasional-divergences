{
  "hash": "d855a7ac8ea18f2cce49b4c9cc4ee3b2",
  "result": {
    "markdown": "---\ntitle: \"Reproducible environments for R and Python\"\nauthor: \"Marc Dotson\"\ndate: \"2023-10-11\"\ndescription: |\n  Reproducible environments are a pain, but {renv} makes things easy for R and works well with venv for Python. Add pyenv, and you should be covered.\ncategories:\n  - r\n  - python\nimage: figures/xkcd_python-env.png\nslug: rep-env\n---\n\n\nReproducible environments. If you're primarily a Pythonista, you're likely already familiar with the necessity. And the horror. XKCD did it best:\n\n![](figures/xkcd_python-env.png){width=60% fig-align=\"center\"}\n\nIf you're primarily an R user, you might not be familiar with either the necessity or the horror of reproducible environments. This post is about facilitating the former and minimizing the latter. I've written this primarily for R users, especially those who, like me, find themselves supplementing their existing R workflows with Python. We'll focus on using {renv} to create reproducible environments for R and Python, along with some venv and pyenv.\n\n## What is a reproducible environment?\n\nYou already work in an environment. It's composed of the packages you use and their dependencies along with R and Python for a given project. What makes it reproducible is keeping track of *which* version of those packages, their dependencies, and R and Python you're using for your given project. While \"keeping track\" could happen in many different ways, ideally you want to keep track of your environment such that it can be easily *reproduced* on another machine, by you (including future you) or someone else.\n\nOkay, but *why*? Packages change. Functions get deprecated. And R and Python continue to evolve. Just because your project code works now doesn't mean that it will work for someone else or in the future. (Technically, your environment could be extended to your operating system version as well, depending on the project, but worrying about machine images is beyond the scope of this post.) Ensuring your project environment is reproducible enables collaboration, future-proofing, and open science.\n\n## R\n\nThere are many ways to create reproducible environments in R, but [{renv}](https://rstudio.github.io/renv/index.html) recently reached 1.0.0 and has a streamlined workflow that helps minimize the horror for both R and Python (more on that in a bit). As an R user, you should already be familiar with working in a [project](https://r4ds.hadley.nz/workflow-scripts.html#projects).\n\nOnce you have {renv} installed, get started with your existing project or a new project by calling `renv::init()`. This will create two essential items in your project's working directory:\n\n1. A **lockfile** called `renv.lock`.\n2. A **project library** called `/renv`.\n\nMore on both of these in a minute. An `.Rprofile` file is also created that will automatically run when you open your project and make sure you're using the correct reproducible environment. If for whatever reason you don't get a prompt in the Console saying that {renv} is running when you open your project after it's been initialized, you may have to jump start this by calling `renv::load()`. Also, please note that if you're using some sort of [version control](https://happygitwithr.com), you'll commit all three of these additions to your project (an automatically generated `/renv/.gitignore` file will make this simple if you're using Git).\n\nIt will help to think about creating a reproducible environment in two parts:\n\n1. The version of R you're using for your project.\n2. The version of the packages (and dependencies) you're using for your project.\n\nLet's discuss each in turn.\n\n### Version\n\nIf you're like me, you don't often think about which version of R you're using. I often wait for a little while after a new version is released to make sure there aren't any breaking problems with the packages and software I use most (I'm looking at you, compilers). I also find myself reminding students to *not* update to the most recent version of R mid-semester for that same reason. You probably just update R a few times a year, maybe notice the version number and its cute [Peanuts](https://en.wikipedia.org/wiki/Peanuts)-themed release name when you open a new instance, and call it good.\n\nWhen you called `renv::init()`, the first thing that was recorded in the `renv.lock` **lockfile** (which tracks the versions of everything to make your environment reproducible) was the version of R you're using. The lockfile is a json, and those details will look something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  \"R\": {\n    \"Version\": \"4.3.1\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://packagemanager.posit.co/cran/latest\"\n      }\n    ]\n  }\n}\n```\n:::\n\n\nWhile {renv} records this information to track your R version, it can't really help a collaborator or future you get this version of R because {renv} is running *inside* of R. However, this probably isn't an issue. You likely only have a single version of R installed at any given time. When you update R, you likely overwrite the old version with the new version. And that's probably enough. R is a specialized language that the operating system isn't using elsewhere and has from its beginning been committed to remaining backwards compatible. All of which to say, a version of R that is *at least* as current as the one you're using for your project will likely be sufficient for others, including future you.\n\nThat said, if you find yourself needing to maintain multiple versions of R on the same computer, you'll want to invest the time in a version management tool like [rig](https://github.com/r-lib/rig).\n\n### Packages\n\nIt may come as a surprise, but I also don't often think about which version of packages I'm using. You might be similar. You might update your packages when prompted or do that manually once a year. Much like most R users maintain a single version of R, by default all packages are installed in a single, global library (where a library is simply a directory with installed packages) known as the **system library**. When you called `renv::init()`, the `/renv` folder that was created is now your **project library**. This helps highlight an important feature of reproducible workflows: Each project will have its own project library and thus be *isolated*. If two projects use different versions of the same package, they won't conflict with each other because they'll each have their own project library.\n\nWell, not *exactly*. {renv} uses something called a **global package cache**. You only ever need to install the version of a given package once. If that same version is needed for another project, {renv} will just link your project library to the corresponding package version in that global cache.\n\nSo how do you track the version of the packages and their dependencies for your project? Once you've installed the packages you need for your project, call `renv::snapshot()`. This takes a snapshot of your package version and records them in the lockfile, along with the R version as shown above. Whenever you add new packages, or update the version of packages you're using, call `renv::snapshot()` to update the lockfile accordingly. When someone else is trying to reproduce your environment, once they have your project working directory, they simply need to call `renv::restore()` to install the correct version of the required packages.\n\nI've tried to provide enough detail to explain why it works the way it does, but the workflow itself remains simple. Let's review:\n\n1. Create a new lockfile and project library once by calling `renv::init()`.\n2. Track installed package versions, and any changes to the project library, using `renv::snapshot()`.\n3. Reproduce the environment by installing the correct project library with `renv::restore()`.\n\nThere are [many other functions](https://rstudio.github.io/renv/reference/index.html) available to manage specific problems or are at work behind the scenes. For example, whenever you open a new instance of a given project that uses {renv}, `renv::status()` will automatically run to check for inconsistencies between the lockfile and what is available in the project library. When issues are found, follow the prompts to address them. This may mean calling `renv::restore()` to get certain packages installed or using `renv::snapshot()` to resolve inconsistencies between what is actually being used in your project's code and what is being tracked in the lockfile.\n\n## Python\n\nThere are even *more* ways to create reproducible environments in Python than there are in R. Since this is written primarily for R users who are supplementing their workflows with Python, we'll continue using {renv} while adding pyenv and showing how {renv} works with venv. That's a lot of envs, so let's get to it. Again, it's helpful to think about creating a reproducible environment in two parts:\n\n1. The version of Python you're using for your project.\n2. The version of the packages (and dependencies) you're using for your project.\n\nLet's address each of these in turn.\n\n### Version\n\nUnlike R users, Pythonistas have *always* had to worry about which version of Python they're using. There are a number of reasons for this, and a few might provide some helpful context:\n\n- R was developed by statisticians while Python was developed by computer scientists. It shows.\n- Python is a big tent with many different uses beyond data science. More uses and users has resulted in a plethora of opinionated approaches to versions and environments.\n- Not all Python versions are backwards compatible.\n- Python comes pre-installed on many operating systems since some of the actual operating system uses that specific version of Python. This is a version you *should not use* for any of your project work.\n\nFor all of these reasons (if not the last reason alone), you need the ability to maintain multiple versions of Python on the same computer, which means you should invest the time to learn how to use a version management tool. While there are many version management tools, I recommend [pyenv](https://github.com/pyenv/pyenv), which is designed to be a *simple* version management tool.\n\n::: {.callout-warning title=\"Python Version Management\"}\nPython version management is where the horror comes in. This is true for R users, but remember that it's also true for Python users (re: the XKCD comic above). While pyenv is simple, it will require you to use the command line (i.e., terminal or shell). Be patient and *take your time* walking carefully through the [installation instructions](https://github.com/pyenv/pyenv#installation). A few things to help as you install:\n\n- The command line is the programming interface into your operating system itself. You don't have to know everything about it to follow instructions.\n- When you get to the section [Set up your shell environment for pyenv](https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv), the instructions are different based on the *type* of command line. If you're on a Mac that's running macOS Catalina 10.15.7 or later, the terminal is Zsh. If you're using Linux, the shell is Bash (and you probably already know that).\n\nNow that you have pyenv installed, you can install and manage all the versions of Python on your computer. To see what versions you already have installed, on the command line, run `pyenv versions`. At first this is probably just the system version. Note that if you've installed Python before, it won't be listed: `pyenv versions` will only list the system version and any additional versions you install. To see all the available versions of Python that you can install, run `pyenv install --list`. This can be overwhelming, but a good place to start is a version of python that has a stable release (i.e., doesn't have a `-dev` tag). For example, to install Python 3.11.5, run `pyenv install 3.11.5`.\n\nRemember how you shouldn't use the system version of Python? You can set the default version of Python that you'll use (leaving the operating system to do it's own thing). For example, to set Python 3.11.5 as the default global version, run `pyenv global 3.11.5`. If you run `pyenv versions` again you should see an asterisk by the default you specified.\n\nThere's a lot more that [pyenv can do](https://realpython.com/intro-to-pyenv/), but if you've been able to follow all of this so far, you should be set to safely manage and use Python.\n:::\n\nYou need to let {renv} know that you're also using Python for your project. (And if you're working in RStudio, that technically means letting [{reticulate}](https://rstudio.github.io/reticulate/) know.) You can do this by calling `renv::use_python()`. You should get a prompt asking you to select the version of Python you want to use. This should probably be the latest version you've installed. Doing this will update the lockfile to include version information for both R and Python, which will look something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  \"R\": {\n    \"Version\": \"4.3.1\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://packagemanager.posit.co/cran/latest\"\n      }\n    ]\n  },\n  \"Python\": {\n    \"Version\": \"3.11.5\",\n    \"Type\": \"virtualenv\",\n    \"Name\": \"./renv/python/virtualenvs/renv-python-3.11\"\n  }\n}\n```\n:::\n\n\nAs before, this tracks the Python version but it can't really help a collaborator or future you get this version of Python.\n\n????\n\nFor that, we need to use pyenv in the command line again once we've navigated to our project's working directory. The most straightforward way to do this is to use the Terminal pane if we're using RStudio. There we can run `pyenv local 3.11.5`, or whatever version of Python we want to use for this project.\n\n- `pyenv local <PYTHON VERSION>`: creates a `.python-version` file\n\nThis will create a `.python-version` file in your project directory that specifies the version of Python you're using. This file is automatically tracked by {renv} and will be used to create a project-specific Python environment.\n\n\nThe Python environment associated with the project will load automatically when using Python from R?\n\n### Packages\n\nUse `renv::use_python()` to tell {renv} to create and use a project-local Python environment. Assuming this is all through {reticulate}, it's stored easily as another part of the lockfile. Then all of the functions, `snapshot()`, `restore()`, etc. will operate for R and Python simultaneously.\n\n- Is it in the correct environment?\n- Can I load sklearn or is its cache borked as well?\n- `!pip install -r requirements.txt`\n- What is the relationship between renv and venv?\n- A `requirements.txt` is added once `snapshot()` includes Python packages as well.\n\n## Final thoughts\n\nIt's environments all the way down.\n\nI've tried to provide enough detail to explain why it works the way it does, but the workflow itself remains simple. Let's review:\n\n1. Create a new lockfile and project library once by calling `renv::init()`.\n2. Track installed package versions, and any changes to the project library, using `renv::snapshot()`.\n3. Reproduce the environment by installing the correct project library with `renv::restore()`.\n\nThere are [many other functions](https://rstudio.github.io/renv/reference/index.html) available to manage specific problems or are at work behind the scenes. For example, whenever you open a new instance of a given project that uses {renv}, `renv::status()` will automatically run to check for inconsistencies between the lockfile and what is available in the project library. When issues are found, follow the prompts to address them. This may mean calling `renv::restore()` to get certain packages installed or using `renv::snapshot()` to resolve inconsistencies between what is actually being used in your project's code and what is being tracked in the lockfile.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}