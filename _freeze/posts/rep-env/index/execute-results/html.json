{
  "hash": "6d24ba0edea3336d14031c1dfaffc9bd",
  "result": {
    "markdown": "---\ntitle: \"Reproducible environments for R and Python\"\nauthor: \"Marc Dotson\"\ndate: \"2023-10-13\"\ndescription: |\n  Reproducible environments are a pain, but {renv} makes things easy for R and works well with venv for Python. Add pyenv, and you should be covered for both R and Python.\ncategories:\n  - r\n  - python\nimage: figures/xkcd_python-env.png\nslug: rep-env\n---\n\n\nReproducible environments. If you're primarily a Pythonista, you're likely already familiar with the necessity. And the horror. XKCD did it best:\n\n![](figures/xkcd_python-env.png){width=60% fig-align=\"center\"}\n\nIf you're primarily an R user, you might not be familiar with either the necessity or the horror of reproducible environments. This post is about facilitating the former and minimizing the latter. I've written this primarily for R users, especially those who, like me, find themselves supplementing their existing R workflows with Python. We'll focus on using {renv} to create reproducible environments for R and Python, along with some venv and pyenv.\n\n## What is a reproducible environment?\n\nYou already work in an environment. It's composed of the packages you use and their dependencies along with R and Python for a given project. What makes it reproducible is keeping track of *which* version of those packages, their dependencies, and R and Python you're using for your given project. While \"keeping track\" could happen in many different ways, ideally you want to keep track of your environment such that it can be easily *reproduced* on another machine, by you (including future you) or someone else.\n\nOkay, but *why*? Packages change. Functions get deprecated. And R and Python continue to evolve. Just because your project code works now doesn't mean that it will work for someone else or in the future. (Technically, your environment could be extended to your operating system version as well, depending on the project, but worrying about machine images is beyond the scope of this post.) Ensuring your project environment is reproducible enables collaboration, future-proofing, and open science.\n\n## R\n\nThere are many ways to create reproducible environments in R, but [{renv}](https://rstudio.github.io/renv/index.html) recently reached 1.0.0 and has a streamlined workflow that helps minimize the horror for both R and Python (more on that in a bit). As an R user, you should already be familiar with working in a [project](https://r4ds.hadley.nz/workflow-scripts.html#projects).\n\nOnce you have {renv} installed, get started with your existing project or a new project by calling `renv::init()`. This will create two essential items in your project's working directory:\n\n1. A **lockfile** called `renv.lock`.\n2. A **project library** called `/renv`.\n\nMore on both of these in a minute. An `.Rprofile` file is also created that will automatically run when you open your project and make sure you're using the correct reproducible environment. If for whatever reason you don't get a prompt in the Console saying that {renv} is running when you open your project after it's been initialized, you may have to jump start this by calling `renv::load()`. Also, please note that if you're using some sort of [version control](https://happygitwithr.com), you'll commit all three of these additions to your project (an automatically generated `/renv/.gitignore` file will make this simple if you're using Git).\n\nIt will help to think about creating a reproducible environment in two parts:\n\n1. The version of R you're using for your project.\n2. The version of the packages (and dependencies) you're using for your project.\n\nLet's discuss each in turn.\n\n### Version\n\nIf you're like me, you don't often think about which version of R you're using. I often wait for a little while after a new version is released to make sure there aren't any breaking problems with the packages and software I use most (I'm looking at you, compilers). I also find myself reminding students to *not* update to the most recent version of R mid-semester for that same reason. You probably just update R a few times a year, maybe notice the version number and its cute [Peanuts](https://en.wikipedia.org/wiki/Peanuts)-themed release name when you open a new instance, and call it good.\n\nWhen you called `renv::init()`, the first thing that was recorded in the `renv.lock` **lockfile** (which tracks the versions of everything to make your environment reproducible) was the version of R you're using. The lockfile is a json, and, as an FYI, those details will look something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  \"R\": {\n    \"Version\": \"4.3.1\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://packagemanager.posit.co/cran/latest\"\n      }\n    ]\n  }\n}\n```\n:::\n\n\nWhile {renv} records this information to track your R version, it can't really help you or a collaborator get this version of R because {renv} is running *inside* of R. However, this probably isn't an issue. You likely only have a single version of R installed at any given time. When you update R, you likely overwrite the old version with the new version. And that's probably enough. R is a specialized language that the operating system isn't using elsewhere and has from its beginning been committed to remaining backwards compatible. All of which to say, a version of R that is *at least* as current as the one you're using for your project will likely be sufficient for others, including future you.\n\nThat said, if you find yourself needing to maintain multiple versions of R on the same computer, you'll want to invest the time in an R version management tool like [rig](https://github.com/r-lib/rig).\n\n### Packages\n\nI also don't often think about which version of packages I'm using (*shocker*, I know). Maybe you're similar. You might update your packages when prompted or do that manually once a year. Much like most R users maintain a single version of R, by default all packages are installed in a single, global library (where a library is simply a directory with installed packages) known as the **system library**. When you called `renv::init()`, the `/renv` folder that was created is now your **project library**. This helps highlight an important feature of reproducible workflows: Each project will have its own project library and thus be *isolated*. If two projects use different versions of the same package, they won't conflict with each other because they'll each have their own project library.\n\nWell, not *exactly*. {renv} uses something called a **global package cache**. You only ever need to install the version of a given package once. If that same version is needed for another project, {renv} will just link your project library to the corresponding package version in that global cache.\n\nSo how do you track the version of the packages and their dependencies for your project? Once you've installed the packages you need for your project, call `renv::snapshot()`. This takes a snapshot of your package version and records them in the lockfile, along with the R version as shown above. Whenever you add new packages, or update the version of packages you're using, call `renv::snapshot()` to update the lockfile accordingly. When someone else is trying to reproduce your environment, once they have your project working directory, they simply need to call `renv::restore()` to install the correct version of the required packages.\n\nI've tried to provide enough detail to explain why {renv} works the way it does, but the workflow itself remains simple. Let's review:\n\n1. Create a new lockfile and project library once by calling `renv::init()`.\n2. Track installed package versions, and any changes to the project library, using `renv::snapshot()`.\n3. Reproduce the environment on another machine by installing the correct project library with `renv::restore()`.\n\nThere are [many other functions](https://rstudio.github.io/renv/reference/index.html) available to manage specific problems or are at work behind the scenes. For example, whenever you open a new instance of a given project that uses {renv}, `renv::status()` will automatically run to check for inconsistencies between the lockfile and what is available in the given project library. When issues are found, follow the prompts to address them. This may mean calling `renv::restore()` to get certain packages installed or using `renv::snapshot()` to resolve inconsistencies between what is actually being used in your project's code and what is being tracked in the lockfile.\n\n## Python\n\nThere are even *more* ways to create reproducible environments in Python than there are in R. Since this is written primarily for R users who are supplementing their workflows with Python, we'll continue using {renv} while adding pyenv and showing how {renv} works with venv. That's a lot of envs, so let's get to it. Again, it's helpful to think about creating a reproducible environment in two parts:\n\n1. The version of Python you're using for your project.\n2. The version of the packages (and dependencies) you're using for your project.\n\nLet's address each of these in turn.\n\n### Version\n\nUnlike R users, Pythonistas have *always* had to worry about which version of Python they're using. There are a number of reasons for this, and a few will provide some helpful context:\n\n- Python is a big tent with many different uses beyond data science. More uses and users has resulted in a plethora of opinionated approaches to versions and environments.\n- Not all Python versions are (or were) backwards compatible.\n- Most importantly, Python comes pre-installed on many operating systems since some of the actual operating system uses that specific version of Python. This is a version you *should not use* for any of your project work.\n\nFor all of these reasons (if not the last one alone), you need the ability to maintain multiple versions of Python on the same computer, which means you should invest the time to learn how to use a Python version management tool. While there are many version management tools, I recommend [pyenv](https://github.com/pyenv/pyenv), which is designed to be as *simple* as possible. Though what constitutes \"simple\" is a matter of experience and your mileage may vary.\n\n::: {.callout-warning title=\"Python Version Management\"}\nPython version management is where the horror can happen. This is true for R users, but remember that it's also true for Python users (re: the XKCD comic above). While pyenv is simple, it will require you to use the command line (i.e., terminal or shell). Be patient and *take your time* walking carefully through the [installation instructions](https://github.com/pyenv/pyenv#installation). Daniel Chen also has a [great write-up](https://chendaniely.github.io/python_setup/210-python_install.html) of the installation instructions that may be a bit easier to follow. A few things to help as you install:\n\n- The command line is the programming interface into your operating system itself. You don't have to know everything about it to follow instructions.\n- When you get to the section [Set up your shell environment for pyenv](https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv), the instructions are different based on the *type* of command line. If you're on a Mac that's running macOS Catalina 10.15.7 or later, the terminal is Zsh. If you're using Linux, the shell is Bash (and you probably already know that).\n\nNow that you have pyenv installed, you can install and manage all the versions of Python on your computer. To see what versions you already have installed, on the command line, run `pyenv versions`. At first this is probably just the system version. Note that if you've installed Python before pyenv, it won't be listed: `pyenv versions` will only list the system version and any additional versions you install using pyenv. To see all the available versions of Python that you can install, run `pyenv install --list`. This can be overwhelming, but a good place to start is the latest a version of Python that has a stable release (i.e., doesn't have a `-dev` tag). For example, to install Python 3.11.5, run `pyenv install 3.11.5`.\n\nRemember how you shouldn't use the system version of Python? You can set the default version of Python that you'll use (leaving the operating system to do it's own thing). For example, to set Python 3.11.5 as the default global version, run `pyenv global 3.11.5`. If you run `pyenv versions` again you should see an asterisk by the global default you specified.\n\nThere's a lot more that [pyenv can do](https://realpython.com/intro-to-pyenv/), but now you should be set to safely manage and use Python.\n:::\n\nYou need to let {renv} know that you're also using Python for your project along with which version you're using. (And if you're working in RStudio, that technically means letting [{reticulate}](https://rstudio.github.io/reticulate/) know.) This is a lot like calling `renv::init()` again, but for the Python parts of your project specifically. You can do this, assuming again that you're using Python 3.11.5, by calling `renv::use_python(python = \"~/.pyenv/versions/3.11.5/bin/python3\")`. Doing this will update the lockfile to include version information for both R and Python, which will look something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  \"R\": {\n    \"Version\": \"4.3.1\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://packagemanager.posit.co/cran/latest\"\n      }\n    ]\n  },\n  \"Python\": {\n    \"Version\": \"3.11.5\",\n    \"Type\": \"virtualenv\",\n    \"Name\": \"./renv/python/virtualenvs/renv-python-3.11\"\n  }\n}\n```\n:::\n\n\nAs before, this tracks the Python version but it can't really help a collaborator or future you get this version of Python. What it can do is let you know which version of Python was used. A version of Python that is *at least* as current as the one you're using for your project will likely be sufficient for others, including future you. However, to ensure that you keep using the same version of Python for your project, you'll need to add a line to that new `.Rprofile` file. As a reminder, it's the file that {renv} added that runs automatically when you open the project. For example, to set 3.11.5 as the default for the project, add `Sys.setenv(RETICULATE_PYTHON = \"~/.pyenv/versions/3.11.5/bin/python3\")` on a new line in `.Rprofile`. Another benefit of using pyenv is that this file path should be the same for anyone else who has 3.11.5 installed (typical file path shennanigans between operating systems aside).\n\n::: {.callout-note title=\"Python Virtual Environments (Part One)\"}\nSpeaking of future-proofing, let's quickly review how this would work with pyenv if you were using Python alone. This comparison will hopefully help solidify the concepts involved, regardless of your workflow.\n\nIf we were just working with Python, after navigating to our project's working directory in the command line, we would run `pyenv local 3.11.5`, assuming again we want Python 3.11.5 to be set as the default. This will create a `.python-version` file in that directory that specifies the version of Python to use for that project. This is equivalent in the R and Python workflow to modifying the `.Rprofile` file to specify the version of Python {reticulate} should use for that project.\n\n| **R and Python** | **Python**   |\n|------------------|--------------|\n| `.Rprofile` | `.python-version` |\n:::\n\n### Packages\n\nUsing `renv::use_python()` also created the project library (also called a **virtual environment**) for Python within `/renv`. This uses the built-in virtual environment tool that comes with Python called venv.\n\n#### renv-test\n\n- Confirm that the venv is made and activated.\n- Start Python by calling some Python code or `reticulate::repl_python()`.\n- Install Python packages: `!pip install <PACKAGE>`. Global cache may need to be purged if you're new to using pyenv and have already done some Python work: `pip cache purge`.\n- Call `renv::snapshot()` to create a `requirements.txt` file.\n- Restore will install the requirements file. `pip install -r requirements.txt`?\n\nParallel the Packages section for R above and use renv-test to test the workflow and update it as part of the final thoughts below.\n\n::: {.callout-note title=\"Python Virtual Environments (Part Two)\"}\nParallel using {renv} with how it would work with Python only. Also to help further explain reproducible workflows.\n:::\n\n## Final thoughts\n\nIt's environments all the way down.\n\nI've tried to provide enough detail to explain why it works the way it does, but the workflow itself remains simple. Let's review:\n\n1. Create a new lockfile and project library once by calling `renv::init()`.\n2. Track installed package versions, and any changes to the project library, using `renv::snapshot()`.\n3. Reproduce the environment by installing the correct project library with `renv::restore()`.\n\nThere are [many other functions](https://rstudio.github.io/renv/reference/index.html) available to manage specific problems or are at work behind the scenes. For example, whenever you open a new instance of a given project that uses {renv}, `renv::status()` will automatically run to check for inconsistencies between the lockfile and what is available in the project library. When issues are found, follow the prompts to address them. This may mean calling `renv::restore()` to get certain packages installed or using `renv::snapshot()` to resolve inconsistencies between what is actually being used in your project's code and what is being tracked in the lockfile.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}